    
P1=[('S', "TE"),("E", "mSE"), ("E","epsilon"),("T","FR"),("R", "xFR"), ("R", epsilon),("F","i"),("F","aSc")]
P = [('S','F'),('F','(S+F)'),('F','a')]
P=[("S","VS"),("S",epsilon),("V","Di"),("D","Y"),("D",epsilon),("Y","UG"),("G","lUG"),("G",epsilon),("U","t"),("U","b"),("U","(Y)")]
P=[('S', "aBDh"),("B", "cC"), ("C","bC"),("C",epsilon),("D", "EF"), ("E", "g"),("E",epsilon),("F","f"),("F",epsilon)]
P = [('S','Aa'),('S','b'),('A','Ac'),('A','Sd'),('A',epsilon)]
P = [('S','A'),('A','aA'),('A','a')]

def leftRecursion(grammar):
    
v     for i in range(len(grammar['N'])):
        for j in range(len(grammar['N'])-1):
            for derivation in grammar['P']:
                if derivation[0] == grammar['N'][i]:
                    if derivation[1][0] == grammar['N'][j]:
                        delta = []
                        for der in grammar['P']:
                            if der[0] == grammar['N'][j] and der[1][0] == grammar['N'][j]:
                                if der[1] != epsilon:
                                    delta.append(der[1])
                            if len(delta) != 0:
                                gamma = derivation[1][1:]
                                grammar['P'].remove(derivation)
                                for d in delta:
                                    tup = (derivation[0],d+gamma)
                                    grammar['P'].append(tup)
            beta = []
        gamma = []
        toDelete = []
        for derivation in grammar['P']:
            if derivation[0] == grammar['N'][i]:
                if derivation[1][0] ==  grammar['N'][i]:
                    toDelete.append(derivation)
                    beta.append(derivation[1][1:])
                else:
                    gamma.append(derivation[1])
        if len(beta) == 0:
            continue
        else:
            newN =  random.choice(string.ascii_letters).upper()
            while newN in grammar['N']:
                newN =  random.choice(string.ascii_letters).upper()
            grammar['N'].append(newN)
            for delete in toDelete:
                grammar['P'].remove(delete)
            for g in gamma:
                tup = (grammar['N'][i],g+newN)
                grammar['P'].append(tup)
            for b in beta:
                tup = (newN,b+newN)
                grammar['P'].append(tup)
            tup = (newN,epsilon)
            grammar['P'].append(tup)
    return grammar



    head = Node(0, [("T",dot+"S")])
grammar = makeHash(P)
first = First(grammar)
follow = Follow(grammar,first)
I = closure(P, head)
states = getStates(I)
table = parsingTableAux(grammar,states)
table = parsingTable(table,I,grammar['P'],follow)
printTable(table)
